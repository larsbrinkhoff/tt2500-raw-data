(setq dis '(100  
int	(jump init)
fd	(jump forward)
rt	(jump rotate)
fd@	(jump forward@)
rt@	(jump rotate@)
jmp	(jump jump1)
cnd	(jump cond>)
ad	(jump add)
st	(jump setvar)
hm	(jump home)
csub	(jump callsub)
pp	(jump pop)
PD	(JUMP PENDOWN)
PU	(JUMP PENUP)
bg	(jump begin)
rf	(jump begin 1)
	(nop)
	(nop)
	(nop)
	(nop)
INIT	(CONSTANT 3777 1 $ ADDRESS OF PDL )
	(CONSTANT 6 0 $  PUT PDL PTR IN RAM6 )
	(S-0 TO D-MA)
	(S-1 TO D-BUS $ STORE 3777 IN RAM6)
begin	(jump home)
	(constant 500 7)
continue-user	(s-7 to d-ma)
	(lod s-3   $ instruction in reg-3)
	(from s-3 d-md)
	(inc s-7)
	(constant 1023 2  $  last reg of cm)
	(from s-wir d-2)
	(jsr jam)
	(jump 1023)
jam	(from s-wcm d-3)
next	(s-7 to d-ma)
	(lod s-0 )
 (from s-0 d-md)
	(INC S-7 $ INCREMENT PC )
	(ret)


home	(minus s-0 d-0 $ x1,x2,y1,y2 in ram2-5)
	(s-1 minus d-1 $ 0 hdg in ram1 )
	(jsr write-1)
	(constant 255. 1)
	(jsr write-1)
	(nop)
	(jsr write-1)
	(nop)
	(jsr write-1)
	(nop)
	(jsr write-1)
	(jump continue-user)
rotate	(JSR NEXT $ PUTS NEW DATA IN REG0)
ROTATE1	(JSR SETvar-3  $   PLACES HDG IN S-1,360 IN S-2,90 IN S-3, TRIG IN S-4)
	(PLUS S-1 D-0  $ ASSUME INPUT IN S-0 UNNORMALIZED HDG IN S-1 TO NORMALIZE: IF <0 ADD 360,IF >360 SUB 360 )
	(COND C-UN IFFALSE ADJUST-TOP)
	(PLUS S-1 D-2)
	(JUMP STORE-HDG)
ADJUST-TOP	(MINUS S-0 D-0)
	(S-2 TO D-0)
	(MINUS D-0 S-1)
	(COND C-UN IFFALSE STORE-HDG)
	(minus S-1 D-2)
STORE-HDG	(MINUS S-0 D-0)
	(JSR WRITE-1)
	(JUMP continue-user  $ SKIP STUFF FOR FD )
EXIT	(MINUS S-0 D-0)
	(INC S-0  $ PUT 1 IN S-0 )
	(JSR WRITE-1  $  EXPECTS ADDRESS IN 0, CONTENTS IN 1)
	(TO d-1 s-2  $ DONT CARE ABOUT S-1 ANY MORE )
	(JSR WRITE-1)
	(TO d-1 s-3)
	(JSR WRITE-1)
	(TO d-1 s-4)
	(JSR WRITE-1)
	(JUMP continue-user  $ BAC TO continue-user-DISP)

WRITE-1	(INC S-0 $  +1 TO S0 )
	(TO S-0 D-MA)
	(TO S-1 D-BUS )
	(NOP)
	(RET)


SETvar-3	(MINUS S-1 D-1)
	(INC S-1)
	(TO S-1 D-MA $ GET HDG FROM RAM-1)
	(LOD S-1 )
	(from s-1 d-md)
	(CONSTANT 360. 2 )
	(CONSTANT 90. 3)
	(RET)


READ-4	(MINUS S-4 D-4)
	(INC S-4)
	(INC S-4  $ GET READY TO POINT TO RAM(2) )
	(TO S-4 D-MA)
	(LOD S-1 )
	(from s-1 d-md)
	(INC S-4)
	(TO S-4 D-MA)
	(LOD S-2 )
	(from s-2 d-md)
	(INC S-4)
	(TO S-4 D-MA)
	(LOD S-3 )
	(from s-3 d-md)
	(INC S-4)
	(TO S-4 D-MA)
	(LOD S-4 )
	(from s-4 d-md)
	(RET)

FORWARD	(JSR NEXT $ GET INPUT AND PUT IT IN R0 )
FORWARD1	(S-1 MINUS D-1 $  DX,DY IN R5,R6 )
	(INC S-1)
	(S-1 TO D-MA)
	(LOD S-1   $ S-1  HDG )
	(CONSTANT 90. 3)
	(S-1 MINUS D-3 $ FIND QUADRANT HDG-90)
	(COND C-UN FORWARD++ $ IFT MEANS HDG <=90 )
	(S-1 MINUS D-3)
	(COND C-UN FORWARD+- $ IFT 90<HDG<180 )
	(S-1 MINUS D-3)
	(COND C-UN FORWARD--)
	(S-1 MINUS D-3)
	(COND C-UN FORWARD-+)

FORWARD-+	(JSR TRIG)
	(JSR READ-4)î
	(PLUS S-2 D-5)
	(COND C-UC IFFALSE YINC-+)
	(DEC S-1)
	(DISX)
YINC-+	(PLUS S-4 D-6)
	(COND C-UC IFFALSE COUNT-+)
	(INC S-3)
	(DISY)
COUNT-+	(DEC S-0)
	(COND C-UN EXIT)
	(JUMP FORWARD-+ 2)

FORWARD+-	(JSR TRIG)
	(JSR READ-4)
	(PLUS S-2 D-5)
	(COND C-UC IFFALSE YINC+-)
	(INC S-1)
	(DISX)
YINC+-	(PLUS S-4 D-6)
	(COND C-UC IFFALSE COUNT+-)
	(DEC S-3)
	(DISY)
COUNT+-	(DEC S-0)
	(COND C-UN EXIT)
	(JUMP FORWARD+- 2)

FORWARD--	(JSR TRIG)
	(JSR READ-4)
	(PLUS S-2 D-6)
	(COND C-UC IFFALSE YINC--)
	(DEC S-1)
	(DISX)
YINC--	(PLUS S-4 D-5)
	(COND C-UC IFFALSE COUNT--)
	(DEC S-3)
	(DISY)
COUNT--	(DEC S-0)
	(COND C-UN EXIT)
	(JUMP FORWARD--  2)
forward++	(jsr trig)
	(jsr read-4)
	(plus s-2 d-6)
	(cond c-uc iffalse yinc++)
	(inc s-1)
	(disx)
yinc++	(plus s-4 d-5)
	(cond  c-uc iffalse count++)
	(inc s-3)
	(disy)
count++	(dec s-0)
	(cond c-un exit)
	(jump forward++ 2)


TRIG	(S-1 PLUS D-3  $ RESTORE HDG TO POSITIVE)
	(CONSTANT 100 6  $ TRIG TABLE STARTS AT RAM(100) )
	(S-1 PLUS D-6  $ LOCATION OF ABS(SIN HDG) )
	(S-1 TO D-MA  $  ADDRESS OF SIN(HDG)  )
	(LOD S-5  $ DELTAX IN REG-5 )
	(from s-5 d-md)
	(PLUS S-1 D-3 $ 100+HDG+90 )
	(S-1 TO D-MA  $  ADDRESS OF COS(HDG)  )
	(LOD S-6   $ DELTA Y IN REG-6 )
	(from s-6 d-md)
	(RET)



CALLSUB 	(CONSTANT 6 2 $ GETPDL PTR FROM RAM(6),WAS 3777 AT START USER PROG IN 500 )

	(S-2 TO D-MA)
	(LOD S-1)
	(from s-1 d-md)
	(DEC S-1)
	(S-0 TO D-7)
	(jsr next $ get top of pdl)
	(s-1 to d-ma)
	(s-7 to d-bus $ saves old pc)
	(nop)
	(s-2 to d-ma)
	(s-1 to d-bus $ save new pdl)
	(nop)
	(s-0 to d-7)
	(JUMP continue-user)

POP	(CONSTANT 6 0)
	(S-0 TO D-MA  $  PDL POINTER IN THE ADDRESS )
	(LOD S-1  $  GET THE PDL LEADER )
	(from s-1 d-md)
	(S-1 TO D-MA)
	(LOD S-7)
	(from s-7 d-md)
	(S-0 TO D-MA)
	(LOD S-1)
	(from s-1 d-md)
	(INC S-1)
	(S-1 TO D-BUS $ INCREASE BY 1 AND  PUT PDL LEADER BACK )
	(JUMP CONTINUE-USER)
FORWARD@	(JSR NEXT)
	(S-0 TO D-MA)
	(LOD S-0)
	(from s-0 d-md)
	(JUMP FORWARD1)

ROTATE@	(JSR NEXT)
	(S-0 TO D-MA)
	(LOD S-0)
	(from s-0 d-md)
	(JUMP ROTATE1)

COND>	(JSR NEXT  $ COND (CONST VAR ADDR FOR VAR> ADDR FOR VAR< ) )

	(S-0 TO D-MA)
	(LOD S-1 $ CONSTANT IN REG-1)
	(from s-1 d-md)
	(JSR NEXT)
	(S-0 TO D-MA)
	(LOD S-2  $  VARIABLE IN REG-2)
	(from s-2 d-md)
	(MINUS S-2 D-1)
	(COND C-UN VARLESS)
	(JSR NEXT)

	(S-0 TO D-7)
	(JUMP continue-user)
varless	(JSR NEXT)
	(S-0 TO D-7)
	(JUMP continue-user)

JUMP1	(JSR NEXT)
	(S-0 TO D-7)
	(JUMP BEGIN)

SETvar	(JSR NEXT)
	(S-0 TO D-MA)
	(JSR NEXT)
	(S-0 TO D-BUS)
	(NOP)
	(jump continue-user)

ADD	(JSR NEXT  $  ADD VAR NUM -- INC CONTENT OF RAM(VAR) BY NUM)
	(S-0 TO D-MA $  PUT VAR IN MA)
	(LOD S-2  $ CONTENTS OF VAR IN R-2)
	(from s-2 d-md)
	(S-0 TO D-1 $ PRESERVE POINTER TO VAR)
	(JSR NEXT $ NUM IN R-0)
	(PLUS S-2 D-0 $  NEW VALUE FOR VAR)
	(S-1 TO D-MA $ PUT IT AWAY )
	(S-2 TO D-BUS)
	(NOP)
	(jump continue-user)
PENDOWN	(S-0 MINUS D-0)
	(DEC S-0)
	(440004)
	(JUMP CONTINUE-USER)

PENUP	(s-0 minus D-0)
	(440004)
	(JUMP CONTINUE-USER)


))
